# Архитектура Проекта Trader
**Версия:** 1.0 (валидировано на 2025-11-15)

## 1. Обзор

Проект `Trader` — это .NET-приложение, предназначенное для выполнения арбитражных сделок на основе данных о спредах, получаемых от проекта `Collections`.

**Текущее состояние:** На данный момент приложение функционирует в режиме **обнаружения, но не исполнения**. Оно успешно подключается к источнику спредов, обнаруживает прибыльные возможности, но фактический вызов торговой логики еще не реализован (см. `DecisionMaker`).

## 2. Основные компоненты

Архитектура разделена на три основных логических модуля: `Host`, `Core` и `Exchanges`.

### 2.1. `Host` (Точка входа)

*   **`Program.cs`**: Консольное приложение, которое служит точкой входа.
    *   **Ответственность:**
        1.  Чтение конфигурации из `appsettings.json` (в частности, URL для `SpreadListener`).
        2.  Инициализация и связывание ключевых сервисов: `SpreadListener` и `DecisionMaker`.
        3.  Запуск основного цикла приложения путем вызова `listener.StartAsync()`.

### 2.2. `Core` (Ядро бизнес-логики)

Этот модуль содержит основную логику принятия решений и исполнения сделок.

*   **`SpreadListener`**:
    *   **Ответственность:** Подключается по WebSocket к `SpreadAggregator` (проект `Collections`), получает данные о спредах в реальном времени.
    *   **Логика:** Если спред превышает жестко заданный порог (0.25%), инициирует событие `OnProfitableSpreadDetected`, передавая направление арбитража (например, `GateIo_To_Bybit`).

*   **`DecisionMaker`**:
    *   **Ответственность:** Реагировать на событие `OnProfitableSpreadDetected` и запускать соответствующий торговый цикл.
    *   **Текущая реализация:** **НЕ ПОЛНАЯ.** Метод `HandleProfitableSpread` содержит `TODO`-заглушку. Он устанавливает флаг `_isCycleInProgress`, чтобы предотвратить параллельные запуски, но **не вызывает** реальную торговую логику. Таким образом, на данный момент это конечная точка процесса.

*   **`ArbitrageTrader` и `ReverseArbitrageTrader` (Проектная реализация):**
    *   **Ответственность:** Эти классы *предназначены* для инкапсуляции логики полного торгового цикла для каждого направления (Leg 1 и Leg 2).
    *   **Предполагаемая логика:** Должны управлять всем процессом: от размещения `trailing` ордера на покупку на одной бирже до рыночного ордера на продажу на другой, отслеживая состояние и P&L.
    *   **Статус:** Не интегрированы с `DecisionMaker`.

*   **`IExchange` (Интерфейс):**
    *   **Ответственность:** Определяет универсальный контракт для взаимодействия с любой биржей. Включает методы для получения баланса, размещения ордеров, подписки на обновления и т.д. Это ключевой элемент паттерна "Адаптер".

### 2.3. `Exchanges` (Адаптеры к биржам)

*   **Ответственность:** Содержит конкретные реализации интерфейса `IExchange` для каждой биржи (Bybit, Gate.io). Этот слой изолирует основную логику от деталей API каждой конкретной биржи.
*   **Примеры:**
    *   `BybitExchange`: Реализация для Bybit.
    *   `GateIoExchange`: Реализация для Gate.io.

## 3. Архитектурные паттерны

*   **Наблюдатель (Observer):** `SpreadListener` выступает в роли издателя, а `DecisionMaker` — в роли подписчика. Это обеспечивает слабую связанность между обнаружением и действием.
*   **Адаптер (Adapter):** Интерфейс `IExchange` позволяет основной логике работать с любой биржей через единый контракт, в то время как классы в модуле `Exchanges` адаптируют этот контракт к специфике каждой биржи.
*   **Одиночка (Singleton) / Управление состоянием:** Флаг `_isCycleInProgress` в `DecisionMaker` является простой реализацией блокировки для предотвращения одновременного выполнения нескольких торговых циклов.

## 4. Внешние зависимости

*   **`SpreadAggregator` (проект `Collections`):** Является источником данных о спредах, к которому `SpreadListener` подключается по WebSocket.
*   **`appsettings.json`:** Файл конфигурации, определяющий URL для подключения к `SpreadAggregator`.
*   **Библиотеки для работы с биржами:** `Bybit.Net`, `GateIo.Net` и др.