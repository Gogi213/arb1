# ISSUE-004: Итеративная отладка отслеживания баланса USDT в Leg 1

- **Severity:** High
- **Status:** In Progress
- **Author:** Kilo Code
- **Date:** 2025-10-29

---

## 1. Исходная проблема

В рамках `PROPOSAL-2025-0037` была поставлена задача заставить `ArbitrageTrader` (Leg 1) после продажи на Bybit дожидаться стабилизации баланса `USDT` и возвращать его точное значение.

## 2. Итерации отладки

### Итерация 1: Ошибка компиляции

-   **Проблема:** После добавления подписки на баланс в `BybitExchange` и `BybitLowLatencyWs`, сборка не удалась с ошибкой `CS0246: Не удалось найти тип или имя пространства имен "BybitOrderAdapter"`.
-   **Причина:** В `BybitLowLatencyWs.cs` отсутствовала директива `using TraderBot.Exchanges.Bybit.Adapters;`.
-   **Решение:** Директива была добавлена.

### Итерация 2: Неверный парсинг баланса

-   **Проблема:** Программа завершалась преждевременно. Логи показали, что `ArbitrageTrader` получал `0` в качестве финального баланса `USDT`.
-   **Причина:** `BybitBalanceUpdate` пытался парсить поле `availableToWithdraw`, которое в ответе от Bybit было пустым (`""`).
-   **Решение:** Логика парсинга была изменена, чтобы использовать более надежное поле `walletBalance`.

### Итерация 3: Race Condition с таймером

-   **Проблема:** Программа снова получала `0` в качестве баланса.
-   **Причина:** Был обнаружен race condition. Таймер `_quoteAssetDebounceTimer` инициализировался в `HandleSellOrderUpdate` слишком поздно. Обновление баланса по WebSocket приходило раньше, чем таймер был создан, что приводило к его игнорированию.
-   **Решение:** Инициализация обоих таймеров (`_baseAssetDebounceTimer` и `_quoteAssetDebounceTimer`) была перенесена в метод `StartAsync`, чтобы гарантировать их создание до начала любых асинхронных операций.

### Итерация 4: Некорректная итерация по балансам

-   **Проблема:** Программа снова получала `0` в качестве баланса.
-   **Причина:** Логика в `HandleBalanceUpdate` некорректно итерировалась по `dataArray`, вместо того чтобы итерироваться по вложенному массиву `coin`.
-   **Решение:** Логика `HandleBalanceUpdate` была исправлена для корректной итерации по `coinArray`.

### Итерация 5: Повторное использование TaskCompletionSource

-   **Проблема:** Программа снова получала `0` в качестве баланса.
-   **Причина:** `TaskCompletionSource` является одноразовым. После того как он был завершен в первом цикле, он не мог быть использован снова.
-   **Решение:** После каждого `await ...Tcs.Task` добавлено пересоздание объекта: `_baseAssetBalanceTcs = new TaskCompletionSource<decimal>();`.

## 3. Завершение отладки Шага 1

После серии исправлений, связанных с парсингом, race condition и пересозданием `TaskCompletionSource`, **Шаг 1 был успешно протестирован**. Логи подтверждают, что `ArbitrageTrader` теперь корректно отслеживает и возвращает финальный баланс `USDT` после продажи на Bybit.

## 4. Новая проблема: Сбой размещения ордера в Leg 2 (РЕШЕНО)

-   **Проблема:** `Leg 2` (`ReverseArbitrageTrader`) не мог разместить лимитный ордер на покупку на Bybit.
-   **Причина:** В `Program.cs` создавалось два независимых экземпляра `BybitLowLatencyWs`, что приводило к конфликту соединений.
-   **Решение:** Был выполнен рефакторинг (`PROPOSAL-2025-0038`), и теперь используется единый экземпляр `BybitExchange`. Проблема решена.

## 5. Финальная проблема: Некорректный поток данных в Leg 2

-   **Проблема:** Цикл выполняется, но он "странный". `Leg 2` для своей продажи на Gate.io использует данные о количестве, оставшиеся от `Leg 1`.
-   **Причина:** `ReverseArbitrageTrader` не отслеживает свой собственный баланс после покупки и обращается к устаревшему общему состоянию (`_state.GateIoLeg1BuyQuantity`).
-   **Статус:** Причина подтверждена логами. Требуется реализация Шага 2 из `PROPOSAL-2025-0037`.
