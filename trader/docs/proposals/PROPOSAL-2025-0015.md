# PROPOSAL-2025-0015: Финальное исправление: парсинг и использование `cumExecQty`

## 1. Диагностика

- **Файлы:** `trader/src/Exchanges/Bybit/BybitLowLatencyWs.cs`, `trader/src/Exchanges/Bybit/Adapters.cs`
- **Проблема:** Класс `BybitOrderUpdate`, отвечающий за парсинг ответа от Bybit, не считывает поле `cumExecQty` (фактически исполненное количество). Вместо этого используется поле `qty`, которое не всегда содержит актуальное значение, что приводит к отправке ордера с нулевым количеством на Gate.io.
- **Серьезность:** `Blocker`

## 2. Предлагаемые изменения

### Шаг 1: Добавить `cumExecQty` в `BybitOrderUpdate`

В файле `trader/src/Exchanges/Bybit/BybitLowLatencyWs.cs` необходимо добавить новое свойство и логику его парсинга.

```diff
--- a/trader/src/Exchanges/Bybit/BybitLowLatencyWs.cs
+++ b/trader/src/Exchanges/Bybit/BybitLowLatencyWs.cs
@@ -667,6 +667,7 @@
         public long OrderId { get; }
         public decimal Price { get; }
         public decimal Quantity { get; }
+        public decimal CumulativeQuantityFilled { get; }
         public string Status { get; }
         public string? FinishType { get; }
         public DateTime? CreateTime { get; }
@@ -678,6 +679,7 @@
             OrderId = data.TryGetProperty("orderId", out var oid) ? long.Parse(oid.GetString() ?? "0") : 0;
             Price = data.TryGetProperty("price", out var pr) && decimal.TryParse(pr.GetString(), out var price) ? price : 0;
             Quantity = data.TryGetProperty("qty", out var q) && decimal.TryParse(q.GetString(), out var qty) ? qty : 0;
+            CumulativeQuantityFilled = data.TryGetProperty("cumExecQty", out var cq) && decimal.TryParse(cq.GetString(), out var cqty) ? cqty : 0;
             Status = data.TryGetProperty("orderStatus", out var st) ? st.GetString() ?? "" : "";
             FinishType = Status == "Filled" ? "Filled" : Status == "Cancelled" ? "Cancelled" : null;
 

```

### Шаг 2: Исправить `BybitOrderAdapter` для использования нового свойства

В файле `trader/src/Exchanges/Bybit/Adapters.cs` нужно изменить `BybitOrderAdapter`, чтобы он использовал `CumulativeQuantityFilled` из `BybitOrderUpdate`.

**Важно:** Поскольку мы теперь работаем с нашим внутренним классом `BybitOrderUpdate`, а не с библиотечным `BybitOrder`, нужно изменить тип принимаемого в конструкторе объекта.

```diff
--- a/trader/src/Exchanges/Bybit/Adapters.cs
+++ b/trader/src/Exchanges/Bybit/Adapters.cs
@@ -8,20 +8,22 @@
  {
      public class BybitOrderAdapter : IOrder
      {
-         private readonly BybitOrder _order;
+         // Используем наш внутренний класс, а не библиотечный
+         private readonly BybitOrderUpdate _order;
  
-         public BybitOrderAdapter(BybitOrder order)
+         public BybitOrderAdapter(BybitOrderUpdate order)
          {
              _order = order;
          }
  
          public string Symbol => _order.Symbol;
          public long OrderId => _order.OrderId;
          public decimal Price => _order.Price;
-         public decimal Quantity => _order.Quantity;
+         // Теперь используем правильное поле для исполненного количества
+         public decimal Quantity => _order.CumulativeQuantityFilled > 0 ? _order.CumulativeQuantityFilled : _order.Quantity;
          public string Status => _order.Status.ToString();
-         public string? FinishType => _order.Status == OrderStatus.Filled ? "Filled" :
-                                       _order.Status == OrderStatus.Cancelled ? "Cancelled" : null;
+         public string? FinishType => _order.Status == "Filled" ? "Filled" :
+                                       _order.Status == "Cancelled" ? "Cancelled" : null;
          public DateTime? CreateTime => _order.CreateTime;
          public DateTime? UpdateTime => _order.UpdateTime;
      }

```

### Шаг 3: Исправить вызов адаптера в `BybitLowLatencyWs.cs`

Нужно убедиться, что в `HandleOrderUpdate` мы передаем в адаптер правильный объект.

```diff
--- a/trader/src/Exchanges/Bybit/BybitLowLatencyWs.cs
+++ b/trader/src/Exchanges/Bybit/BybitLowLatencyWs.cs
@@ -478,7 +478,8 @@
                  {
                      foreach (var orderData in dataArray.EnumerateArray())
                      {
-                         Console.WriteLine($"[WS-PRIVATE-EVENT] Handling order update: {orderData.ToString()}");
-                         var order = new BybitOrderUpdate(orderData);
-                         _orderUpdateCallback(order);
+                        var orderUpdate = new BybitOrderUpdate(orderData);
+                        var adapter = new BybitOrderAdapter(orderUpdate);
+                        _orderUpdateCallback(adapter);
                      }
                  }
              }

```

## 3. Обоснование

Этот набор изменений комплексно решает проблему:
1.  Мы добавляем недостающее поле в нашу модель данных.
2.  Мы используем это поле в адаптере для корректного представления исполненного количества.
3.  Мы исправляем вызов адаптера, чтобы вся цепочка работала правильно.

Это гарантирует, что в `ReverseArbitrageTrader` придет объект `IOrder` с ненулевым `Quantity`, и ордер на продажу на Gate.io будет сформирован с верными данными.

## 4. Шаги для отката

`git checkout -- trader/src/Exchanges/Bybit/BybitLowLatencyWs.cs trader/src/Exchanges/Bybit/Adapters.cs`

## 5. Оценка рисков

- **Риск:** Низкий.
- **Обоснование:** Изменения логичны и исправляют явную ошибку в потоке данных.

## 6. План тестирования

1.  Применить все три изменения.
2.  Запустить приложение.
3.  Спровоцировать исполнение `Leg 2`.
4.  Убедиться по логам, что `[Y5 DEBUG]` показывает ненулевое количество, и что ордер на Gate.io успешно размещается.