# PROPOSAL-2025-0020: Standardize Order Quantity to Base Asset

## 1. Diagnostic
- **Files Affected:**
  - `trader/src/Exchanges/Bybit/BybitLowLatencyWs.cs`
  - `trader/src/Core/ArbitrageTrader.cs`
  - `trader/src/Exchanges/Bybit/ReverseArbitrageTrader.cs`
- **Problem:** The system uses inconsistent units for order placement. Bybit uses the quote asset (`USDT`) for market orders (`marketUnit: "quoteCoin"`), while Gate.io expects the base asset (`H`). This creates discrepancies and potential for errors, as seen in the `BALANCE_NOT_ENOUGH` issue.
- **Severity:** `high`

## 2. Proposed Change Set

### Rationale
To eliminate ambiguity and ensure that we always sell the exact amount we buy, all order placements will be standardized to use the **base asset quantity**. This makes the logic consistent across all exchanges and prevents issues related to price fluctuations between order legs.

### Change 1: Modify Bybit Market Order Placement
Remove the `marketUnit` parameter from `BybitLowLatencyWs.cs`. The `qty` parameter will now represent the base asset amount.

```diff
--- a/trader/src/Exchanges/Bybit/BybitLowLatencyWs.cs
+++ b/trader/src/Exchanges/Bybit/BybitLowLatencyWs.cs
@@ -141,7 +141,7 @@
              var qtyStr = quoteQuantity.ToString("0.########", CultureInfo.InvariantCulture);
  
              // Build JSON with proper Bybit v5 format
-             var orderMessage = $@"{{""reqId"":""{reqId}"",""header"":{{""X-BAPI-TIMESTAMP"":""{timestamp}"",""X-BAPI-RECV-WINDOW"":""5000""}},""op"":""order.create"",""args"":[{{""category"":""spot"",""symbol"":""{symbol}"",""side"":""{side}"",""orderType"":""Market"",""qty"":""{qtyStr}"",""marketUnit"":""quoteCoin""}}]}}";
+             var orderMessage = $@"{{""reqId"":""{reqId}"",""header"":{{""X-BAPI-TIMESTAMP"":""{timestamp}"",""X-BAPI-RECV-WINDOW"":""5000""}},""op"":""order.create"",""args"":[{{""category"":""spot"",""symbol"":""{symbol}"",""side"":""{side}"",""orderType"":""Market"",""qty"":""{qtyStr}""}}]}}";
  
              var t0 = DateTime.UtcNow;
              await SendMessageAsync(_tradeWs, _tradeSendLock, orderMessage, "TRADE");

```

### Change 2: Update `ArbitrageTrader` Logic
Modify the sell leg to use the exact `Quantity` from the filled buy order.

```diff
--- a/trader/src/Core/ArbitrageTrader.cs
+++ b/trader/src/Core/ArbitrageTrader.cs
@@ -80,7 +80,7 @@
             var t2 = DateTime.UtcNow;
             Console.WriteLine($"[Y5] Immediately selling on {_sellExchange.GetType().Name}.");
 
-            var sellOrderId = await _sellExchange.PlaceOrderAsync(_symbol, OrderSide.Sell, NewOrderType.Market, price: null, quoteQuantity: _amount);
+            var sellOrderId = await _sellExchange.PlaceOrderAsync(_symbol, OrderSide.Sell, NewOrderType.Market, quantity: filledOrder.Quantity);
             var t3 = DateTime.UtcNow;
 
             var placeLatency = (t3 - t2).TotalMilliseconds;

```

### Change 3: Update `ReverseArbitrageTrader` Logic
Modify the sell leg to use the exact `Quantity` from the filled buy order.

```diff
--- a/trader/src/Exchanges/Bybit/ReverseArbitrageTrader.cs
+++ b/trader/src/Exchanges/Bybit/ReverseArbitrageTrader.cs
@@ -144,7 +144,7 @@
                 var t2 = DateTime.UtcNow;
                 Console.WriteLine($"[Y5] Immediately selling on {_sellExchange.GetType().Name}.");
 
-                var sellOrderId = await _sellExchange.PlaceOrderAsync(_symbol, OrderSide.Sell, NewOrderType.Market, price: null, quoteQuantity: _amount);
+                var sellOrderId = await _sellExchange.PlaceOrderAsync(_symbol, OrderSide.Sell, NewOrderType.Market, quantity: filledOrder.Quantity);
                 var t3 = DateTime.UtcNow;
 
                 var placeLatency = (t3 - t2).TotalMilliseconds;

```

## 3. Rollback Steps
- Revert the changes in the affected files using `git checkout`.

## 4. Risk Assessment
- **Low.** This change standardizes behavior and removes a source of error. The logic becomes more direct and less prone to miscalculation.

## 5. Testing Plan
- Run `Leg 1` and `Leg 2`.
- Verify from the logs that the quantity passed to the sell order on the second exchange exactly matches the `cumExecQty` (or `QuantityFilled`) from the buy order on the first exchange.
- Confirm that no `BALANCE_NOT_ENOUGH` errors occur (assuming sufficient funds exist).