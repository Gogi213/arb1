# PROPOSAL-2025-0023: Dynamic Quantity Rounding Based on Exchange Precision

## 1. Diagnostic
- **Files Affected:**
  - `trader/src/Core/ArbitrageTrader.cs`
  - `trader/src/Exchanges/Bybit/ReverseArbitrageTrader.cs`
- **Problem:** The system failed to place a sell order on Bybit due to incorrect quantity precision ("Order quantity has too many decimals"). My previous proposal (`-0022`) suggested a hardcoded `Math.Floor`, which is a "magic number" and not a systemic solution. Different exchanges and symbols have different precision rules.
- **Severity:** `critical`

## 2. Proof of Concept & Minimalist Design (KISS/YAGNI)

### Proof
1.  **Gate.io Already Provides Precision:** The `GateIoExchange.GetSymbolFiltersAsync` method already correctly fetches `quantity_precision` from the exchange's symbol details and returns it as `basePrecision`.
2.  **Bybit is Ready for It:** The `BybitExchange.GetSymbolFiltersAsync` method currently returns a hardcoded value but is designed to be replaced with a real API call. The infrastructure is in place.
3.  **Universal Rounding is Simple:** C# `Math.Round()` can take the number of decimal places as an argument. A `basePrecision` of `2` means we round to 2 decimal places. A `basePrecision` of `0` (as required by Bybit for `H/USDT`) means we round to a whole number.

### YAGNI/KISS Principle
Instead of creating a complex "Coin" or "Asset" abstraction layer, we can achieve the goal with minimal changes. We will add **one field** (`_basePrecision`) to each trader and use it in **one line** of code where the sell order is created. This avoids over-engineering.

## 3. Proposed Change Set

### Rationale
We will fetch the `basePrecision` (number of allowed decimal places for the base asset) from the **selling exchange** and use it to correctly round the quantity before placing the sell order. This makes the logic robust, dynamic, and compliant with each exchange's rules.

### Change 1: Update `ArbitrageTrader` (Leg 1: Gate.io -> Bybit)
Fetch `basePrecision` from Bybit and use it to round the sell quantity.

```diff
--- a/trader/src/Core/ArbitrageTrader.cs
+++ b/trader/src/Core/ArbitrageTrader.cs
@@ -19,16 +19,20 @@
          private string? _symbol;
          private DateTime? _buyFilledServerTime;
          private DateTime? _buyFilledLocalTime;
+         private int _sellBasePrecision;
  
          public ArbitrageTrader(IExchange buyExchange, IExchange sellExchange)
          {
@@ -38,12 +42,18 @@
              _trailingTrader = new TrailingTrader(_buyExchange);
          }
  
-         public Task StartAsync(string symbol, decimal amount, int durationMinutes)
+         public async Task<bool> StartAsync(string symbol, decimal amount, int durationMinutes)
          {
              _symbol = symbol;
              Console.WriteLine($"--- Starting ArbitrageTrader for {symbol} ---");
              Console.WriteLine($"Buy on: {_buyExchange.GetType().Name}, Sell on: {_sellExchange.GetType().Name}");
  
+             // Get precision for the SELL exchange to round quantities correctly
+             var sellSymbol = symbol.Replace("_", "");
+             var (_, basePrecision) = await _sellExchange.GetSymbolFiltersAsync(sellSymbol);
+             _sellBasePrecision = (int)basePrecision;
+             Console.WriteLine($"[Setup] Sell exchange precision: {_sellBasePrecision} decimal places.");
+
              // Subscribe to sell exchange order updates for confirmation
              _sellExchange.SubscribeToOrderUpdatesAsync(HandleSellOrderUpdate);
  
@@ -52,7 +62,7 @@
              // Start the buying process on the buyExchange (don't await it here)
              _trailingTrader.StartAsync(symbol, amount, durationMinutes);
  
-             return _arbitrageCycleTcs.Task;
+             return await _arbitrageCycleTcs.Task;
          }
  
          private async Task CleanupAndSignalCompletionAsync()
@@ -90,13 +100,16 @@
  
                  // Bybit uses a different symbol format (without underscore)
                  var sellSymbol = filledOrder.Symbol.Replace("_", "");
-                 var sellAmountUsd = 5m; // Minimum for Bybit spot market order
+
+                 // Round the quantity according to the sell exchange's rules
+                 var sellQuantity = Math.Round(filledOrder.Quantity, _sellBasePrecision);
+                 Console.WriteLine($"[Arbitrage] Original buy quantity: {filledOrder.Quantity}, rounded sell quantity: {sellQuantity}");
  
                  var t2 = DateTime.UtcNow;
                  var sellOrderId = await _sellExchange.PlaceOrderAsync(
                      sellSymbol,
                      OrderSide.Sell,
                      NewOrderType.Market,
-                     quoteQuantity: sellAmountUsd);
+                     quantity: sellQuantity);
                  var t3 = DateTime.UtcNow;
  
                  var placeOrderLatency = (t3 - t2).TotalMilliseconds;

```

### Change 2: Update `ReverseArbitrageTrader` (Leg 2: Bybit -> Gate.io)
Fetch `basePrecision` from Gate.io and use it. This makes the logic symmetrical and robust for the future.

```diff
--- a/trader/src/Exchanges/Bybit/ReverseArbitrageTrader.cs
+++ b/trader/src/Exchanges/Bybit/ReverseArbitrageTrader.cs
@@ -23,7 +23,7 @@
          private DateTime? _buyFilledServerTime;
          private DateTime? _buyFilledLocalTime;
          private decimal _tickSize;
-         private int _basePrecision;
+         private int _sellBasePrecision;
  
          public ReverseArbitrageTrader(BybitLowLatencyWs bybitWs, IExchange gateIoExchange)
          {
@@ -32,7 +32,7 @@
              _bybitTrailingTrader = new BybitTrailingTrader(_bybitWs);
          }
  
-         public Task StartAsync(string symbol, decimal amount, int durationMinutes)
+         public async Task<bool> StartAsync(string symbol, decimal amount, int durationMinutes)
          {
              _symbol = symbol;
              Console.WriteLine($"[Y1] --- Starting ReverseArbitrageTrader for {symbol} ---");
@@ -49,10 +49,10 @@
              var bybitSymbol = symbol.Replace("_", "");
  
              // Get symbol filters (hardcoded in BybitExchange for now)
-             Console.WriteLine($"[Y2] Getting filters for {bybitSymbol}...");
-             _tickSize = 0.00001m; // HUSDT typical tick size
-             _basePrecision = 0; // HUSDT base precision (H token)
-             Console.WriteLine($"[Y2] Filters: TickSize={_tickSize}, BasePrecision={_basePrecision}");
+             Console.WriteLine($"[Y2] Getting filters...");
+             var (buyTickSize, buyBasePrecision) = await _bybitWs.GetSymbolFiltersAsync(bybitSymbol);
+             var (sellTickSize, sellBasePrecision) = await _gateIoExchange.GetSymbolFiltersAsync(symbol);
+             _sellBasePrecision = (int)sellBasePrecision;
+             Console.WriteLine($"[Y2] Filters: Bybit TickSize={buyTickSize}, Gate.io Sell Precision={_sellBasePrecision}");
  
              // Note: Balance query not implemented yet in BybitLowLatencyWs
              Console.WriteLine("[Y2] Balance query skipped (not yet implemented via WS)");
@@ -67,10 +67,10 @@
              Console.WriteLine($"[Y3] Starting Bybit trailing for {bybitSymbol}...");
  
              var dollarDepth = 25m; // $25 depth like Gate.io for faster fills in testing
-             _bybitTrailingTrader.StartAsync(bybitSymbol, amount, dollarDepth, _tickSize, _basePrecision);
+             _bybitTrailingTrader.StartAsync(bybitSymbol, amount, dollarDepth, buyTickSize, (int)buyBasePrecision);
  
              Console.WriteLine("[Y3] Bybit trailing started. Waiting for fill event...");
  
-             // Don't complete immediately - wait for TaskCompletionSource to be set by fill event
-             return _arbitrageCycleTcs.Task;
+             return await _arbitrageCycleTcs.Task;
          }
  
          private async Task CleanupAndSignalCompletionAsync()
@@ -140,13 +140,15 @@
                      : filledOrder.Symbol;
  
                  // Use the actual filled quantity from the Bybit order
-                 var sellQuantity = filledOrder.Quantity;
+                 var sellQuantity = Math.Round(filledOrder.Quantity, _sellBasePrecision);
+                 Console.WriteLine($"[Y5] Original buy quantity: {filledOrder.Quantity}, rounded sell quantity: {sellQuantity}");
  
                  var t2 = DateTime.UtcNow;
                  var sellOrderId = await _sellExchange.PlaceOrderAsync(
                      sellSymbol,
                      OrderSide.Sell,
                      NewOrderType.Market,
-                     quantity: sellQuantity);
+                     quantity: sellQuantity);
                  var t3 = DateTime.UtcNow;
  
                  var placeOrderLatency = (t3 - t2).TotalMilliseconds;

```

## 4. Rollback Steps
- Revert the changes in the affected files using `git checkout`.

## 5. Risk Assessment
- **Very Low.** This change replaces a hardcoded, incorrect assumption with dynamic, exchange-provided data, making the system more robust and correct.

## 5. Testing Plan
- Run `Leg 1`. Verify from the logs that the sell quantity for Bybit is correctly rounded to an integer (0 decimal places).
- Run `Leg 2`. Verify from the logs that the sell quantity for Gate.io is rounded according to its precision rules.
- Confirm both legs execute successfully without "too many decimals" or "balance not enough" errors (assuming sufficient funds).