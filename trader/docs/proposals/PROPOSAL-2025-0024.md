# PROPOSAL-2025-0024: Fix Bybit Precision & Refactor Trader Setup

## 1. Diagnostic
- **Files Affected:**
  - `trader/src/Exchanges/Bybit/BybitExchange.cs`
  - `trader/src/Exchanges/Bybit/ReverseArbitrageTrader.cs`
- **Problem:**
  1. `BybitExchange.GetSymbolFiltersAsync` returns a hardcoded `basePrecision` of `2`, but for `H/USDT` it must be `0`. This causes the "too many decimals" error.
  2. `ReverseArbitrageTrader` contains a compilation error introduced during the last refactoring, attempting to call `GetSymbolFiltersAsync` on `_bybitWs` which does not implement `IExchange`.
- **Severity:** `critical`

## 2. Proposed Change Set

### Rationale
This proposal makes two minimal but critical fixes. First, it corrects the hardcoded precision for Bybit to unblock testing. Second, it fixes a clear refactoring error in `ReverseArbitrageTrader` to make the code compilable and logical.

### Change 1: Correct Hardcoded Precision in `BybitExchange.cs`
Update the `GetSymbolFiltersAsync` method to return the correct precision for `H/USDT`.

```diff
--- a/trader/src/Exchanges/Bybit/BybitExchange.cs
+++ b/trader/src/Exchanges/Bybit/BybitExchange.cs
@@ -31,7 +31,7 @@
              // Hardcoded for now - will be fetched via WS later
              // Bybit spot typical values
              _tickSize = 0.0001m;
-             _basePrecision = 2;
+             _basePrecision = 0; // H/USDT requires integer quantity
  
              Console.WriteLine($"[Bybit] Using hardcoded filters: tickSize={_tickSize}, basePrecision={_basePrecision}");
              return (_tickSize, _basePrecision);

```

### Change 2: Fix `ReverseArbitrageTrader.cs` Setup Logic
The `_bybitWs` client does not implement `IExchange`. We need to get the filters from the `BybitExchange` wrapper itself. Since `ReverseArbitrageTrader` doesn't have a reference to it, we'll pass `_bybitWs` to the `BybitTrailingTrader` and let it handle its own filters.

```diff
--- a/trader/src/Exchanges/Bybit/ReverseArbitrageTrader.cs
+++ b/trader/src/Exchanges/Bybit/ReverseArbitrageTrader.cs
@@ -52,10 +52,9 @@
  
              // Get symbol filters (hardcoded in BybitExchange for now)
              Console.WriteLine($"[Y2] Getting filters...");
-             var (buyTickSize, buyBasePrecision) = await ((IExchange)_bybitWs).GetSymbolFiltersAsync(bybitSymbol);
              var (sellTickSize, sellBasePrecision) = await _gateIoExchange.GetSymbolFiltersAsync(symbol);
              _sellBasePrecision = (int)sellBasePrecision;
-             Console.WriteLine($"[Y2] Filters: Bybit TickSize={buyTickSize}, Gate.io Sell Precision={_sellBasePrecision}");
+             Console.WriteLine($"[Y2] Filters: Gate.io Sell Precision={_sellBasePrecision}");
  
              // Note: Balance query not implemented yet in BybitLowLatencyWs
              Console.WriteLine("[Y2] Balance query skipped (not yet implemented via WS)");
@@ -70,7 +69,7 @@
              Console.WriteLine($"[Y3] Starting Bybit trailing for {bybitSymbol}...");
  
              var dollarDepth = 25m; // $25 depth like Gate.io for faster fills in testing
-             _bybitTrailingTrader.StartAsync(bybitSymbol, amount, dollarDepth, buyTickSize, (int)buyBasePrecision);
+             _bybitTrailingTrader.StartAsync(bybitSymbol, amount, dollarDepth);
  
              Console.WriteLine("[Y3] Bybit trailing started. Waiting for fill event...");
  

```

### Change 3: Update `BybitTrailingTrader` to fetch its own filters
This is the most logical place for this logic, as it's the component that needs it.

```diff
--- a/trader/src/Exchanges/Bybit/BybitTrailingTrader.cs
+++ b/trader/src/Exchanges/Bybit/BybitTrailingTrader.cs
@@ -30,13 +30,18 @@
              _ws = ws;
          }
  
-         public async Task StartAsync(string symbol, decimal amount, decimal dollarDepth, decimal tickSize, int basePrecision)
+         public async Task StartAsync(string symbol, decimal amount, decimal dollarDepth)
          {
              _cts = new CancellationTokenSource();
              _symbol = symbol;
              _amount = amount;
              _dollarDepth = dollarDepth;
-             _tickSize = tickSize;
-             _basePrecision = basePrecision;
+
+             // Fetch filters directly
+             var filters = await _ws.GetSymbolFiltersAsync(symbol);
+             _tickSize = filters.tickSize;
+             _basePrecision = (int)filters.basePrecision;
+             Console.WriteLine($"[BybitTrailing] Filters: TickSize={_tickSize}, BasePrecision={_basePrecision}");
  
              await _ws.SubscribeToOrderUpdatesAsync(HandleOrderUpdate);
              await _ws.SubscribeToOrderBookAsync(symbol, HandleOrderBookUpdate);

```

### Change 4: Add `GetSymbolFiltersAsync` to `BybitLowLatencyWs`
This method is required to make the above change work.

```diff
--- a/trader/src/Exchanges/Bybit/BybitLowLatencyWs.cs
+++ b/trader/src/Exchanges/Bybit/BybitLowLatencyWs.cs
@@ -83,6 +83,16 @@
              await AuthenticateAsync(_tradeWs, "TRADE");
          }
  
+         public Task<(decimal tickSize, decimal basePrecision)> GetSymbolFiltersAsync(string symbol)
+         {
+             // Hardcoded for now - will be fetched via REST/WS later
+             decimal tickSize = 0.00001m;
+             decimal basePrecision = 0; // H/USDT requires integer quantity
+ 
+             Console.WriteLine($"[Bybit] Using hardcoded filters: tickSize={tickSize}, basePrecision={basePrecision}");
+             return Task.FromResult((tickSize, basePrecision));
+         }
+
          private async Task AuthenticateAsync(ClientWebSocket ws, string name)
          {
              Console.WriteLine($"[WS-{name}] Attempting authentication...");

```

## 3. Rollback Steps
- Revert the changes in the affected files using `git checkout`.

## 4. Risk Assessment
- **Low.** This change corrects a hardcoded value and a refactoring error. It moves logic to a more appropriate place (`BybitTrailingTrader`) and makes the system more robust.

## 5. Testing Plan
- Run `Leg 1` and `Leg 2`.
- Verify from the logs that the `basePrecision` for Bybit is now `0`.
- Confirm that the sell order on Bybit in `Leg 1` is placed with a correctly rounded integer quantity and executes successfully.
- Confirm `Leg 2` also runs successfully.