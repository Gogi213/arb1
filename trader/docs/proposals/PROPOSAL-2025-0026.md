# PROPOSAL-2025-0026: Implement Bybit-to-Bybit Quantity Persistence

## 1. Diagnostic

- **Files Affected:**
  - `trader/src/Core/ITrader.cs`
  - `trader/src/Core/ArbitrageTrader.cs`
  - `trader/src/Exchanges/Bybit/ReverseArbitrageTrader.cs`
  - `trader/src/Host/Program.cs`
- **Problem:** The starting volume for the `Leg 2` trading cycle is read from the configuration file and is completely independent of the result of the `Leg 1` cycle. The requirement is to use the actual executed sell volume from `Leg 1` (on Bybit) as the starting buy volume for the subsequent `Leg 2` cycle (also on Bybit). This creates a "Bybit-to-Bybit" quantity persistence loop.
- **Severity:** `medium`

## 2. Proposed Change Set

### Rationale
The current orchestration logic in `Program.cs` treats `Leg 1` and `Leg 2` as isolated processes. To link them, we need to modify the `ITrader` interface to return the final executed quantity of its cycle. This allows the orchestrator (`Program.cs`) to capture the result of `Leg 1` and feed it into `Leg 2`. This approach is clean, maintains separation of concerns, and directly implements the required logic.

### Change 1: Modify `ITrader.cs` Interface
Update the `StartAsync` method signature to return the executed quantity.

```diff
--- a/trader/src/Core/ITrader.cs
+++ b/trader/src/Core/ITrader.cs
@@ -4,7 +4,7 @@
 {
     public interface ITrader
     {
-        Task<bool> StartAsync(string symbol, decimal amount, int durationMinutes);
+        Task<decimal> StartAsync(string symbol, decimal amount, int durationMinutes);
     }
 }
```

### Change 2: Update `ArbitrageTrader.cs` (Leg 1) to Return Executed Quantity
Store the executed sell quantity and return it when the cycle completes.

```diff
--- a/trader/src/Core/ArbitrageTrader.cs
+++ b/trader/src/Core/ArbitrageTrader.cs
@@ -14,11 +14,12 @@
          private readonly SemaphoreSlim _sellLock = new SemaphoreSlim(1, 1);
          private long? _pendingSellOrderId;
          private bool _sellConfirmed;
-         private readonly TaskCompletionSource<bool> _arbitrageCycleTcs = new TaskCompletionSource<bool>();
+         private readonly TaskCompletionSource<decimal> _arbitrageCycleTcs = new TaskCompletionSource<decimal>();
          private string? _symbol;
          private DateTime? _buyFilledServerTime;
          private DateTime? _buyFilledLocalTime;
          private int _sellBasePrecision;
+         private decimal _lastExecutedSellQuantity = 0;
  
          public ArbitrageTrader(IExchange buyExchange, IExchange sellExchange)
          {
@@ -28,7 +29,7 @@
              _trailingTrader = new TrailingTrader(_buyExchange);
          }
  
-         public async Task<bool> StartAsync(string symbol, decimal amount, int durationMinutes)
+         public async Task<decimal> StartAsync(string symbol, decimal amount, int durationMinutes)
          {
              _symbol = symbol;
              FileLogger.LogOther($"--- Starting ArbitrageTrader for {symbol} ---");
@@ -56,7 +57,7 @@
              await _trailingTrader.StopAsync(_symbol);
              await _sellExchange.UnsubscribeAsync();
              FileLogger.LogOther("[Arbitrage] Cleanup finished.");
-             _arbitrageCycleTcs.TrySetResult(true); // Signal that the entire cycle is complete
+             _arbitrageCycleTcs.TrySetResult(_lastExecutedSellQuantity); // Signal that the entire cycle is complete
          }
  
          private async void HandleBuyOrderFilled(IOrder filledOrder)
@@ -158,6 +159,9 @@
                  // Check if filled (Bybit returns Status=Filled for market orders)
                  if (order.Status == "Filled" || order.FinishType == "Filled")
                  {
+                     // Store the actual executed quantity from the sell order
+                     _lastExecutedSellQuantity = order.Quantity;
+
                      FileLogger.LogOther($"[Arbitrage] Sell order {order.OrderId} CONFIRMED filled on {_sellExchange.GetType().Name}!");
  
                      // Calculate end-to-end latency

```

### Change 3: Update `ReverseArbitrageTrader.cs` (Leg 2) to Match Interface
Update the signature and return its own executed sell quantity for consistency.

```diff
--- a/trader/src/Exchanges/Bybit/ReverseArbitrageTrader.cs
+++ b/trader/src/Exchanges/Bybit/ReverseArbitrageTrader.cs
@@ -16,11 +16,12 @@
          private readonly SemaphoreSlim _sellLock = new SemaphoreSlim(1, 1);
          private long? _pendingSellOrderId;
          private bool _sellConfirmed;
-         private readonly TaskCompletionSource<bool> _arbitrageCycleTcs = new TaskCompletionSource<bool>();
+         private readonly TaskCompletionSource<decimal> _arbitrageCycleTcs = new TaskCompletionSource<decimal>();
          private string? _symbol;
          private DateTime? _buyFilledServerTime;
          private DateTime? _buyFilledLocalTime;
          private int _sellBasePrecision;
+         private decimal _lastExecutedSellQuantity = 0;
  
          public ReverseArbitrageTrader(BybitLowLatencyWs bybitWs, IExchange gateIoExchange)
          {
@@ -30,7 +31,7 @@
              _bybitTrailingTrader = new BybitTrailingTrader(_bybitWs);
          }
  
-         public async Task<bool> StartAsync(string symbol, decimal amount, int durationMinutes)
+         public async Task<decimal> StartAsync(string symbol, decimal amount, int durationMinutes)
          {
              _symbol = symbol;
              FileLogger.LogOther($"[Y1] --- Starting ReverseArbitrageTrader for {symbol} ---");
@@ -93,7 +94,7 @@
              FileLogger.LogOther("[Y7] Cleanup finished.");
              FileLogger.LogOther("[Y7] CLEANUP complete.\n");
  
-             _arbitrageCycleTcs.TrySetResult(true);
+             _arbitrageCycleTcs.TrySetResult(_lastExecutedSellQuantity);
          }
  
          private async void HandleBuyOrderFilled(IOrder filledOrder)
@@ -207,6 +208,9 @@
                  // Gate.io returns Status=Finish + FinishType=Filled
                  if (order.Status == "Finish" && order.FinishType == "Filled")
                  {
+                     // Store the actual executed quantity from the sell order
+                     _lastExecutedSellQuantity = order.Quantity;
+
                      FileLogger.LogOther($"[Y6] Sell order {order.OrderId} CONFIRMED filled on {_gateIoExchange.GetType().Name}!");
  
                      // Calculate end-to-end latency

```

### Change 4: Update `Program.cs` Orchestration Logic
Capture the output of `Leg 1` and pass it as input to `Leg 2`.

```diff
--- a/trader/src/Host/Program.cs
+++ b/trader/src/Host/Program.cs
@@ -37,18 +37,28 @@
  
              // LEG 1: Gate.io (BUY limit trailing) -> Bybit (SELL market)
              var arbitrageTrader = new ArbitrageTrader(gateIoExchange, bybitExchange);
-             await arbitrageTrader.StartAsync(gateIoConfig.Symbol, gateIoConfig.Amount, gateIoConfig.DurationMinutes);
+             var leg1SellQuantity = await arbitrageTrader.StartAsync(gateIoConfig.Symbol, gateIoConfig.Amount, gateIoConfig.DurationMinutes);
  
              FileLogger.LogOther("\n[X7] --- LEG 1 (X1-X7) cycle finished ---");
  
-             // LEG 2 (Y1-Y7): Bybit (BUY limit trailing) -> Gate.io (SELL market)
-             FileLogger.LogOther("\n[Y1] --- Starting LEG 2 (Y1-Y7) ---");
-             var bybitLowLatencyWs = new BybitLowLatencyWs(bybitConfig.ApiKey, bybitConfig.ApiSecret);
-             await bybitLowLatencyWs.ConnectAsync();
- 
-             var reverseArbitrageTrader = new ReverseArbitrageTrader(bybitLowLatencyWs, gateIoExchange);
-             await reverseArbitrageTrader.StartAsync(bybitConfig.Symbol, bybitConfig.Amount, bybitConfig.DurationMinutes);
+             if (leg1SellQuantity > 0)
+             {
+                 FileLogger.LogOther($"[Orchestrator] Leg 1 executed sell quantity on Bybit: {leg1SellQuantity}. Using this for Leg 2.");
+                 // LEG 2 (Y1-Y7): Bybit (BUY limit trailing) -> Gate.io (SELL market)
+                 FileLogger.LogOther("\n[Y1] --- Starting LEG 2 (Y1-Y7) ---");
+                 var bybitLowLatencyWs = new BybitLowLatencyWs(bybitConfig.ApiKey, bybitConfig.ApiSecret);
+                 await bybitLowLatencyWs.ConnectAsync();
+
+                 var reverseArbitrageTrader = new ReverseArbitrageTrader(bybitLowLatencyWs, gateIoExchange);
+                 await reverseArbitrageTrader.StartAsync(bybitConfig.Symbol, leg1SellQuantity, bybitConfig.DurationMinutes);
+             }
+             else
+             {
+                 FileLogger.LogOther("[Orchestrator] Leg 1 did not return a valid sell quantity. Skipping Leg 2.");
+             }
  
              FileLogger.LogOther("\n--- Full process (X1-X7 + Y1-Y7) finished. Program exiting. ---");
          }
      }
  }
```

## 3. Rollback Steps
- Revert the changes in the affected files using `git checkout .`.

## 4. Risk Assessment
- **Low.** The changes are primarily in the orchestration layer and interface contracts. The core trading logic within each trader is minimally touched, reducing the risk of unintended side effects. The logic is straightforward and directly implements the user's request.

## 5. Testing Plan
1. Run the application.
2. Verify from the logs that `ArbitrageTrader` (`Leg 1`) correctly logs the final sell quantity from Bybit upon completion.
3. Verify that `Program.cs` logs a message indicating it is using this new quantity for `Leg 2`.
4. Verify that `ReverseArbitrageTrader` (`Leg 2`) starts its `BybitTrailingTrader` with the quantity received from the `Leg 1` cycle, not the value from `appsettings.json`.
5. Confirm both `Leg 1` and `Leg 2` complete successfully.