# PROPOSAL-2025-0029: Спринт 2 - Реализация "идеального свопа" Gate.io -> Gate.io

## 1. Диагностика

- **Файлы:** `trader/src/Host/Program.cs`, `trader/src/Core/ArbitrageTrader.cs`, `trader/src/Exchanges/Bybit/ReverseArbitrageTrader.cs`
- **Проблема:** После выполнения Спринта 1 (`PROPOSAL-2025-0028`) "ноги" арбитража не связаны по объему на бирже Gate.io. Для реализации "идеального свопа" необходимо, чтобы точное количество, купленное на Gate.io в `Leg 1`, было использовано для продажи на Gate.io в `Leg 2`.
- **Серьезность:** `Medium`

## 2. Предлагаемые изменения

### Цель: Создать механизм для передачи количества Gate.io (Leg 1) -> Gate.io (Leg 2)

#### Шаг 1: Создать простое хранилище в `Program.cs`

Мы введем статическое поле для хранения количества, купленного на Gate.io.

```diff
--- a/trader/src/Host/Program.cs
+++ b/trader/src/Host/Program.cs
@@ -12,6 +12,8 @@
 {
      class Program
      {
+         private static decimal _gateIoLeg1BuyQuantity = 0;
+
          static async Task Main(string[] args)
          {
              var configuration = new ConfigurationBuilder()

```

#### Шаг 2: Сохранять количество в `ArbitrageTrader` (`Leg 1`)

Нужно изменить `ArbitrageTrader`, чтобы он не возвращал количество, а сохранял его в наше новое хранилище.

```diff
--- a/trader/src/Core/ArbitrageTrader.cs
+++ b/trader/src/Core/ArbitrageTrader.cs
@@ -11,7 +11,7 @@
     /// </summary>
     public class ArbitrageTrader : ITrader
     {
-        // ... (поля)
+        public static Action<decimal> OnGateIoBuyOrderFilled;
 
         // ... (конструктор)
 
@@ -48,6 +48,7 @@
             FileLogger.LogOther($"[Arbitrage] Buy order {filledOrder.OrderId} filled on {_buyExchange.Name}!");
             // ... (логи)
 
+            OnGateIoBuyOrderFilled?.Invoke(filledOrder.Quantity);
+
             FileLogger.LogOther($"[Arbitrage] Immediately selling on {_sellExchange.Name}.");
             // ... (остальная часть метода)
         }

```

И обновить `Program.cs` для подписки на это событие.

```diff
--- a/trader/src/Host/Program.cs
+++ b/trader/src/Host/Program.cs
@@ -38,8 +38,9 @@
              await bybitExchange.InitializeAsync(bybitConfig.ApiKey, bybitConfig.ApiSecret);
  
              // LEG 1: Gate.io (BUY limit trailing) -> Bybit (SELL market)
+             ArbitrageTrader.OnGateIoBuyOrderFilled = quantity => _gateIoLeg1BuyQuantity = quantity;
              var arbitrageTrader = new ArbitrageTrader(gateIoExchange, bybitExchange);
-             var leg1SellQuantity = await arbitrageTrader.StartAsync(gateIoConfig.Symbol, gateIoConfig.Amount, gateIoConfig.DurationMinutes);
+             await arbitrageTrader.StartAsync(gateIoConfig.Symbol, gateIoConfig.Amount, gateIoConfig.DurationMinutes);
  
              FileLogger.LogOther("\n[X7] --- LEG 1 (X1-X7) cycle finished ---");
 
```

#### Шаг 3: Использовать сохраненное количество в `ReverseArbitrageTrader` (`Leg 2`)

Теперь мы можем использовать сохраненное значение в `ReverseArbitrageTrader` вместо временного решения из Спринта 1.

```diff
--- a/trader/src/Exchanges/Bybit/ReverseArbitrageTrader.cs
+++ b/trader/src/Exchanges/Bybit/ReverseArbitrageTrader.cs
@@ -87,11 +87,9 @@
             FileLogger.LogOther($"[Y4] Buy fill server time: {_buyOrderFilledTime:HH:mm:ss.fff}, Handler entered: {DateTime.UtcNow:HH:mm:ss.fff}");
             FileLogger.LogOther($"[Latency] WS propagation delay (Bybit fill -> handler): {(DateTime.UtcNow - _buyOrderFilledTime).TotalMilliseconds:F0}ms");
 
-            // ВРЕМЕННО: Используем исходное количество из конфига, чтобы разорвать связь.
-            // В Спринте 2 здесь будет логика получения количества из Leg 1 (Gate.io).
-            var sellQuantity = _gateIoExchange.RoundQuantity(filledOrder.Symbol, _amount);
+            var sellQuantity = _gateIoExchange.RoundQuantity(filledOrder.Symbol, Program._gateIoLeg1BuyQuantity);
 
             FileLogger.LogOther($"[Y4] FILL complete. Trigger: Place market SELL on Gate.io");
             FileLogger.LogOther($"[Y5] --- MARKET Phase ---");
-            FileLogger.LogOther($"[Y5] Immediately selling {sellQuantity} on GateIoExchange (using initial amount {_amount}).");
+            FileLogger.LogOther($"[Y5] Immediately selling {sellQuantity} on GateIoExchange (original from Gate.io Leg 1: {Program._gateIoLeg1BuyQuantity}).");
 
             var sellOrder = await _gateIoExchange.PlaceOrderAsync(
                 filledOrder.Symbol,

```
*Примечание: для доступа к `_gateIoLeg1BuyQuantity` его нужно будет сделать `internal static` в `Program.cs`.*

## 3. Обоснование

Эти изменения создают замкнутый цикл для объемов на бирже Gate.io. Количество, купленное в `Leg 1`, будет точно соответствовать количеству, продаваемому в `Leg 2` на той же бирже, что решает проблему с `precision` и `BALANCE_NOT_ENOUGH` и реализует "идеальный своп". Использование `Action` (события) вместо прямого возврата значения делает код более гибким и расширяемым.

## 4. Шаги для отката

`git checkout -- trader/src/Host/Program.cs trader/src/Core/ArbitrageTrader.cs trader/src/Exchanges/Bybit/ReverseArbitrageTrader.cs`

## 5. Оценка рисков

- **Риск:** Средний.
- **Обоснование:** Изменения затрагивают несколько ключевых компонентов и меняют поток данных. Требуется внимательное тестирование, чтобы убедиться, что событие срабатывает корректно и значение правильно передается.

## 6. План тестирования

1.  Применить все изменения из этого `proposal`.
2.  Запустить приложение.
3.  После завершения `Leg 1` убедиться по логам, что `_gateIoLeg1BuyQuantity` было установлено.
4.  После завершения `Leg 2` убедиться по логам, что `ReverseArbitrageTrader` использовал именно это значение для продажи на Gate.io, и что ордер был исполнен успешно.