# PROPOSAL-2025-0030: Fix BALANCE_NOT_ENOUGH error by using post-commission balance

## 1. Compact Diagnostic

- **Files Affected:** `trader/src/Core/ArbitrageTrader.cs`
- **Concrete Problem:** The arbitrage cycle fails during Leg 2's market sell on Gate.io because the quantity to be sold is derived from the pre-commission filled quantity of the Leg 1 buy order. This quantity is slightly larger than the actual available balance after the buy-side commission is deducted, leading to a `BALANCE_NOT_ENOUGH` error from the exchange.
- **Severity:** `high`

## 2. Proposed Change Set

The solution is to make `ArbitrageTrader` event-driven and reactive to balance changes. Instead of immediately triggering a sell based on the order fill event, it will now wait for the corresponding balance update from the buy-side exchange. This ensures the sell order uses the precise, post-commission quantity.

```diff
--- a/trader/src/Core/ArbitrageTrader.cs
+++ b/trader/src/Core/ArbitrageTrader.cs
@@ -14,11 +14,15 @@
          private readonly SemaphoreSlim _sellLock = new SemaphoreSlim(1, 1);
          private long? _pendingSellOrderId;
          private bool _sellConfirmed;
-         private readonly TaskCompletionSource<decimal> _arbitrageCycleTcs = new TaskCompletionSource<decimal>();
+         private readonly TaskCompletionSource<decimal> _arbitrageCycleTcs = new();
          private string? _symbol;
+         private string? _baseAsset;
          private DateTime? _buyFilledServerTime;
          private DateTime? _buyFilledLocalTime;
          private int _sellBasePrecision;
          private decimal _lastExecutedSellQuantity = 0;
          private ArbitrageCycleState _state;
+         private readonly TaskCompletionSource<decimal> _balanceTcs = new();
 
          public ArbitrageTrader(IExchange buyExchange, IExchange sellExchange)
          {
@@ -31,6 +35,7 @@
          public async Task<decimal> StartAsync(string symbol, decimal amount, int durationMinutes, ArbitrageCycleState state)
          {
              _symbol = symbol;
+             _baseAsset = symbol.Split('_')[0];
              _state = state;
              FileLogger.LogOther($"--- Starting ArbitrageTrader for {symbol} ---");
              FileLogger.LogOther($"Buy on: {_buyExchange.GetType().Name}, Sell on: {_sellExchange.GetType().Name}");
@@ -44,6 +49,7 @@
  
              // Subscribe to sell exchange order updates for confirmation
              _sellExchange.SubscribeToOrderUpdatesAsync(HandleSellOrderUpdate);
+             _buyExchange.SubscribeToBalanceUpdatesAsync(HandleBuyBalanceUpdate);
  
              // Subscribe to fill events from the TrailingTrader
              _trailingTrader.OnOrderFilled += HandleBuyOrderFilled;
@@ -58,6 +64,7 @@
              FileLogger.LogOther("[Arbitrage] Cleanup started...");
              await _trailingTrader.StopAsync(_symbol);
              await _sellExchange.UnsubscribeAsync();
+             await _buyExchange.UnsubscribeAsync();
              FileLogger.LogOther("[Arbitrage] Cleanup finished.");
              _arbitrageCycleTcs.TrySetResult(_lastExecutedSellQuantity); // Signal that the entire cycle is complete
          }
@@ -79,8 +86,17 @@
                  _buyFilledLocalTime = t0;
  
                  FileLogger.LogOther($"[Arbitrage] Buy order {filledOrder.OrderId} filled on {_buyExchange.GetType().Name}!");
-                 _state.GateIoLeg1BuyQuantity = filledOrder.Quantity;
                  FileLogger.LogOther($"[Arbitrage] Buy fill server time: {buyFillServerTimeStr}, Handler entered: {t0:HH:mm:ss.fff}");
+                 
+                 // --- NEW LOGIC: Wait for the actual balance update ---
+                 FileLogger.LogOther($"[Arbitrage] Waiting for balance update for asset '{_baseAsset}'...");
+                 
+                 var cancellationTokenSource = new CancellationTokenSource(TimeSpan.FromSeconds(10));
+                 var actualQuantity = await _balanceTcs.Task.WaitAsync(cancellationTokenSource.Token);
+                 
+                 FileLogger.LogOther($"[Arbitrage] Balance update received. Actual available quantity: {actualQuantity}");
+                 _state.GateIoLeg1BuyQuantity = actualQuantity;
+                 // --- END NEW LOGIC ---
  
                  if (buyFillServerTime.HasValue)
                  {
@@ -96,13 +112,13 @@
  
                  FileLogger.LogOther($"[Arbitrage] Immediately selling on {_sellExchange.GetType().Name}.");
  
-                 // Bybit uses a different symbol format (without underscore)
                  var sellSymbol = filledOrder.Symbol.Replace("_", "");
  
                  // Round the quantity according to the sell exchange's rules
-                 var sellQuantity = Math.Round(filledOrder.Quantity, _sellBasePrecision);
-                 FileLogger.LogOther($"[Arbitrage] Original buy quantity: {filledOrder.Quantity}, rounded sell quantity: {sellQuantity}");
+                 // Use the precise quantity from the balance update
+                var sellQuantity = Math.Round(actualQuantity, _sellBasePrecision);
+                FileLogger.LogOther($"[Arbitrage] Original buy quantity from balance: {actualQuantity}, rounded sell quantity: {sellQuantity}");
  
                  var t2 = DateTime.UtcNow;
                  var sellOrderId = await _sellExchange.PlaceOrderAsync(
@@ -138,6 +154,15 @@
              {
                  _sellLock.Release();
              }
+         }
+ 
+         private void HandleBuyBalanceUpdate(IBalance balance)
+         {
+             if (balance.Asset == _baseAsset)
+             {
+                 FileLogger.LogOther($"[Balance Update] Asset: {balance.Asset}, Available: {balance.Available}");
+                 _balanceTcs.TrySetResult(balance.Available);
+             }
          }
  
          private async void HandleSellOrderUpdate(IOrder order)

```

## 3. Rollback Steps

1.  Revert the changes in `trader/src/Core/ArbitrageTrader.cs` to the previous version using `git checkout -- trader/src/Core/ArbitrageTrader.cs`.

## 4. Risk Assessment

- **Risk:** Low. The change is localized to `ArbitrageTrader` and makes the logic more robust by relying on definitive balance updates rather than potentially inaccurate order fill data.
- **Mitigation:** The logic introduces a 10-second timeout for waiting on the balance update. If the update doesn't arrive, the cycle will fail with a timeout exception, which is a clear and diagnosable failure mode, preventing the cycle from hanging indefinitely.

## 5. Testing Plan

1.  Run the arbitrage cycle again with the applied changes.
2.  **Verify Logs:**
    - Confirm that `ArbitrageTrader` logs "Waiting for balance update...".
    - Confirm that a `[Balance Update]` log appears for the base asset (`H`).
    - Confirm that the `sellQuantity` logged for the sell order on Bybit is derived from the `actualQuantity` received from the balance update, not the original order quantity.
    - Confirm that the market sell order on Gate.io in Leg 2 (in `ReverseArbitrageTrader`) now succeeds without a `BALANCE_NOT_ENOUGH` error.
3.  **Final State:** The entire arbitrage cycle should complete successfully.
