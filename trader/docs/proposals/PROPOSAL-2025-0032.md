# PROPOSAL-2025-0032: Внедрение Debounce-механизма для стабилизации баланса

## 1. Диагностика

- **Затронутые файлы:** `trader/src/Core/ArbitrageTrader.cs`
- **Проблема:** Предыдущее исправление было неполным. Код реагировал на *первое* обновление баланса после покупки, но биржа Gate.io присылает несколько последовательных обновлений (например, зачисление, затем списание комиссии). В результате `ArbitrageTrader` захватывал промежуточное, неверное значение баланса, что снова приводило к ошибке `BALANCE_NOT_ENOUGH` в Leg 2.
- **Критичность:** `высокая`

## 2. Предлагаемое изменение

Внедряется механизм "debouncing" с помощью `System.Threading.Timer`. Это позволит дождаться прекращения потока обновлений баланса и взять самое последнее, стабильное значение.

1.  **Новые поля:** Добавляются `_balanceDebounceTimer` и `_lastReceivedBalance` для управления состоянием.
2.  **`HandleBuyBalanceUpdate`:** Теперь этот метод не вызывает `_balanceTcs.TrySetResult` напрямую. Вместо этого он сохраняет последнее значение баланса и перезапускает таймер на 150 мс.
3.  **`OnBalanceDebounceTimer`:** Этот метод, вызываемый по истечении таймера, окончательно фиксирует последнее полученное значение баланса, завершая `TaskCompletionSource`.

Это гарантирует, что мы будем действовать только после того, как баланс "успокоится".

```diff
--- a/trader/src/Core/ArbitrageTrader.cs
+++ b/trader/src/Core/ArbitrageTrader.cs
@@ -22,6 +22,8 @@
          private decimal _lastExecutedSellQuantity = 0;
          private ArbitrageCycleState _state;
          private readonly TaskCompletionSource<decimal> _balanceTcs = new();
+         private Timer? _balanceDebounceTimer;
+         private decimal _lastReceivedBalance;
  
          public ArbitrageTrader(IExchange buyExchange, IExchange sellExchange)
          {
@@ -60,6 +62,7 @@
              FileLogger.LogOther("[Arbitrage] Cleanup started...");
              await _trailingTrader.StopAsync(_symbol);
              await _sellExchange.UnsubscribeAsync();
+             _balanceDebounceTimer?.Dispose();
              await _buyExchange.UnsubscribeAsync();
              FileLogger.LogOther("[Arbitrage] Cleanup finished.");
              _arbitrageCycleTcs.TrySetResult(_lastExecutedSellQuantity); // Signal that the entire cycle is complete
@@ -83,6 +86,9 @@
                  FileLogger.LogOther($"[Arbitrage] Buy fill server time: {buyFillServerTimeStr}, Handler entered: {t0:HH:mm:ss.fff}");
                  
                  // --- NEW LOGIC: Wait for the actual balance update ---
+                 _balanceDebounceTimer = new Timer(OnBalanceDebounceTimer, null, Timeout.Infinite, Timeout.Infinite);
+
                  FileLogger.LogOther($"[Arbitrage] Waiting for balance update for asset '{_baseAsset}'...");
                  
                  var cancellationTokenSource = new CancellationTokenSource(TimeSpan.FromSeconds(10));
@@ -138,12 +144,20 @@
              }
          }
  
-         private void HandleBuyBalanceUpdate(IBalance balance)
+        private void HandleBuyBalanceUpdate(IBalance balance)
          {
              if (balance.Asset == _baseAsset)
              {
                  FileLogger.LogOther($"[Balance Update] Asset: {balance.Asset}, Available: {balance.Available}");
-                 _balanceTcs.TrySetResult(balance.Available);
+                _lastReceivedBalance = balance.Available;
+                // Reset the timer every time an update comes in
+                _balanceDebounceTimer?.Change(150, Timeout.Infinite);
              }
          }
  
+         private void OnBalanceDebounceTimer(object? state)
+         {
+             _balanceTcs.TrySetResult(_lastReceivedBalance);
+         }
+
          private async void HandleSellOrderUpdate(IOrder order)
          {
              var t0 = DateTime.UtcNow;

```

## 3. Шаги для отката

1.  Вернуть изменения в файле `trader/src/Core/ArbitrageTrader.cs` к предыдущей версии с помощью `git checkout -- trader/src/Core/ArbitrageTrader.cs`.

## 4. Оценка рисков

- **Риск:** Низкий. Добавляется небольшая задержка (макс. 150 мс) для стабилизации баланса, что является стандартной практикой для обработки "шумных" событий. В худшем случае, если обновление баланса не придет, цикл завершится по 10-секундному таймауту, как и раньше.

## 5. План тестирования

1.  Запустить полный цикл арбитража.
2.  **Проверить логи:**
    - Убедиться, что после `[!!!] Order ... was FILLED!` появляются **несколько** логов `[Balance Update]`.
    - Убедиться, что лог `[Arbitrage] Balance update received` появляется **после** последнего обновления баланса.
    - Проверить, что количество в логе `[Y5] Immediately selling...` в `ReverseArbitrageTrader` теперь усекается от **самого последнего** значения баланса.
    - Убедиться, что продажа в Leg 2 проходит успешно, без ошибки `BALANCE_NOT_ENOUGH`.
3.  **Конечное состояние:** Весь цикл арбитража должен завершиться успешно.
