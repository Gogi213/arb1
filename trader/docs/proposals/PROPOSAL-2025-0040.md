# PROPOSAL-2025-0040: Implement Target Logic for Full Cycle

## 1. Compact Diagnostic

Based on the user's clarification, the current implementation has two critical flaws preventing a full, correct arbitrage cycle:
1.  **Incorrect `Leg 2` Funding:** `Leg 2` is funded by a hardcoded amount from `appsettings.json` instead of the actual USDT proceeds from the `Leg 1` sale.
2.  **Incorrect `Leg 2` Sell Logic:** The final sell-off in `Leg 2` attempts to sell the quantity just bought on Bybit, instead of selling the initial quantity from Gate.io to rebalance.

This proposal outlines the necessary changes across three files to implement the correct, "golden standard" logic defined in `trader/docs/flows/main_process_flow.md`.

## 2. Proposed Changes

### Change 1: `Program.cs` - Orchestrator Logic

**Purpose:** Fetch and store the initial Gate.io `H` balance, and correctly pass the `Leg 1` USDT proceeds to `Leg 2`.

```diff
<<<<<<< SEARCH
:start_line:38
-------
            var cycleState = new ArbitrageCycleState();

            // LEG 1: Gate.io (BUY limit trailing) -> Bybit (SELL market)
            var arbitrageTrader = new ArbitrageTrader(gateIoExchange, bybitExchange);
            var leg1SellQuantity = await arbitrageTrader.StartAsync(gateIoConfig.Symbol, gateIoConfig.Amount, gateIoConfig.DurationMinutes, cycleState);

            FileLogger.LogOther("\n[X7] --- LEG 1 (X1-X7) cycle finished ---");

            if (leg1SellQuantity > 0)
            {
                FileLogger.LogOther($"[Orchestrator] Leg 1 finished. Starting Leg 2.");
                // LEG 2 (Y1-Y7): Bybit (BUY limit trailing) -> Gate.io (SELL market)
                FileLogger.LogOther("\n[Y1] --- Starting LEG 2 (Y1-Y7) ---");
                var reverseArbitrageTrader = new ReverseArbitrageTrader(bybitExchange, gateIoExchange);
                await reverseArbitrageTrader.StartAsync(bybitConfig.Symbol, bybitConfig.Amount, bybitConfig.DurationMinutes, cycleState);
            }
=======
            var cycleState = new ArbitrageCycleState();

            // Step 0: Get initial H balance from Gate.io
            var baseAsset = gateIoConfig.Symbol.Split('_')[0];
            var initialGateIoBalance = await gateIoExchange.GetBalanceAsync(baseAsset);
            cycleState.InitialGateIoBaseAssetBalance = initialGateIoBalance;
            FileLogger.LogOther($"[Orchestrator] Stored initial Gate.io {baseAsset} balance: {initialGateIoBalance}");

            // LEG 1: Gate.io (BUY limit trailing) -> Bybit (SELL market)
            var arbitrageTrader = new ArbitrageTrader(gateIoExchange, bybitExchange);
            var leg1UsdtResult = await arbitrageTrader.StartAsync(gateIoConfig.Symbol, gateIoConfig.Amount, gateIoConfig.DurationMinutes, cycleState);

            FileLogger.LogOther("\n[X7] --- LEG 1 (X1-X7) cycle finished ---");

            if (leg1UsdtResult > 0)
            {
                FileLogger.LogOther($"[Orchestrator] Leg 1 finished with {leg1UsdtResult} USDT. Starting Leg 2.");
                // LEG 2 (Y1-Y7): Bybit (BUY limit trailing) -> Gate.io (SELL market)
                FileLogger.LogOther("\n[Y1] --- Starting LEG 2 (Y1-Y7) ---");
                var reverseArbitrageTrader = new ReverseArbitrageTrader(bybitExchange, gateIoExchange);
                await reverseArbitrageTrader.StartAsync(bybitConfig.Symbol, leg1UsdtResult, bybitConfig.DurationMinutes, cycleState);
            }
>>>>>>> REPLACE
```

### Change 2: `ArbitrageTrader.cs` - Return Sell Proceeds

**Purpose:** Ensure `Leg 1` returns the actual USDT amount gained from the sale, not the entire wallet balance.

```diff
<<<<<<< SEARCH
:start_line:249
-------
                    var finalUsdtBalance = await _quoteAssetBalanceTcs.Task.WaitAsync(cancellationTokenSource.Token);
                    _quoteAssetBalanceTcs = new TaskCompletionSource<decimal>(); // Re-create for next cycle
                    FileLogger.LogOther($"[Arbitrage] Final USDT balance received: {finalUsdtBalance}");

                    FileLogger.LogOther("[Arbitrage] Cycle complete.");
                    await CleanupAndSignalCompletionAsync(finalUsdtBalance);
=======
                    // We don't need to wait for the full balance. The executed amount is in the order update.
                    var usdtProceeds = order.QuoteQuantity;
                    _quoteAssetBalanceTcs = new TaskCompletionSource<decimal>(); // Re-create for next cycle
                    FileLogger.LogOther($"[Arbitrage] Sale executed. USDT proceeds: {usdtProceeds}");

                    FileLogger.LogOther("[Arbitrage] Cycle complete.");
                    await CleanupAndSignalCompletionAsync(usdtProceeds);
>>>>>>> REPLACE
```

### Change 3: `ReverseArbitrageTrader.cs` - Use Initial Balance for Final Sell

**Purpose:** Modify `Leg 2` to use the initial `H` balance from Gate.io (stored in `cycleState`) for the final rebalancing sale.

```diff
<<<<<<< SEARCH
:start_line:166
-------
                decimal factor = (decimal)Math.Pow(10, _sellBasePrecision);
                var sellQuantity = Math.Truncate(actualQuantity * factor) / factor;
                FileLogger.LogOther($"[Y5] Immediately selling {sellQuantity} on GateIoExchange (original from Bybit Leg 2: {actualQuantity}).");
=======
                decimal factor = (decimal)Math.Pow(10, _sellBasePrecision);
                // Use the initial balance stored at the very beginning of the cycle
                var sellQuantity = Math.Truncate(_state.InitialGateIoBaseAssetBalance * factor) / factor;
                FileLogger.LogOther($"[Y5] Immediately selling {sellQuantity} on GateIoExchange (original from Gate.io pre-cycle balance: {_state.InitialGateIoBaseAssetBalance}).");
>>>>>>> REPLACE
```

## 3. Rationale

These changes collectively align the application's behavior with the target logic:
1.  The orchestrator now correctly captures the initial state and passes the exact proceeds from `Leg 1` to `Leg 2`.
2.  `Leg 1` is modified to return a more precise value (the proceeds of the sale) rather than the entire wallet balance, which could be incorrect.
3.  `Leg 2` now performs the correct rebalancing action by selling the amount of asset `H` that was on Gate.io *before* the cycle started.

## 4. Risk Assessment

- **Risk:** Medium. The changes affect the core logic flow and data passing between components.
- **Mitigation:** The logic is based on a clearly defined and approved flow (`main_process_flow.md`). Each change is small, targeted, and logged, allowing for clear verification.

## 5. Testing Plan

1.  Approve and apply all three diffs.
2.  Ensure the Bybit account has some `H` to sell for `Leg 1` and the Gate.io account has some `USDT` to buy for `Leg 1`.
3.  Run the application.
4.  **Expected Outcome:**
    *   The log will show the initial Gate.io `H` balance being stored.
    *   `Leg 1` will execute.
    *   The log will show the correct USDT proceeds being passed to `Leg 2`.
    *   `Leg 2` will execute its buy on Bybit.
    *   `Leg 2` will execute its final sell on Gate.io using the initially stored `H` quantity.
    *   The full cycle will complete without errors.

## 6. Rollback Steps

-   Revert the changes in all three files (`Program.cs`, `ArbitrageTrader.cs`, `ReverseArbitrageTrader.cs`).