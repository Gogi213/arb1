# PROPOSAL-2025-0042: Implement Final Target Logic

## 1. Compact Diagnostic

Following the clarification of the target logic in `main_process_flow.md`, this proposal outlines the definitive set of changes required to make the application fully functional. It supersedes `-0040` and `-0041`.

The implementation requires four key changes:
1.  **`IOrder` Interface:** Add a property to get the cumulative executed value (`cumExecValue` from Bybit).
2.  **Adapters:** Implement the new property in both Bybit and Gate.io adapters.
3.  **`ArbitrageTrader` (`Leg 1`):** Use the new property to return the precise USDT proceeds from the sale.
4.  **`Program.cs` (Orchestrator):** Fetch the initial Gate.io balance and correctly pass data between legs.
5.  **`ReverseArbitrageTrader` (`Leg 2`):** Use the initial Gate.io balance for the final rebalancing sale.

## 2. Proposed Changes

### Change 1: `IExchange.cs` - Update `IOrder` Interface

```diff
<<<<<<< SEARCH
:start_line:26
-------
        decimal QuoteQuantity { get; }
        string Status { get; }
=======
        decimal QuoteQuantity { get; }
        decimal CumulativeQuoteQuantity { get; }
        string Status { get; }
>>>>>>> REPLACE
```

### Change 2: `Bybit/Adapters.cs` - Implement New Property

```diff
<<<<<<< SEARCH
:start_line:19
-------
        public decimal QuoteQuantity => _order.QuoteQuantity;
        public string Status => _order.Status;
=======
        public decimal QuoteQuantity => _order.QuoteQuantity;
        public decimal CumulativeQuoteQuantity => _order.CumulativeExecutedValue;
        public string Status => _order.Status;
>>>>>>> REPLACE
```

### Change 3: `GateIo/Adapters.cs` - Implement New Property

```diff
<<<<<<< SEARCH
:start_line:21
-------
        public decimal QuoteQuantity => _order.QuoteQuantityFilled;
        public string Status => _order.Event.ToString();
=======
        public decimal QuoteQuantity => _order.QuoteQuantityFilled;
        public decimal CumulativeQuoteQuantity => _order.QuoteQuantityFilled; // Gate.io provides this directly
        public string Status => _order.Event.ToString();
>>>>>>> REPLACE
```

### Change 4: `ArbitrageTrader.cs` - Return Precise Proceeds

```diff
<<<<<<< SEARCH
:start_line:249
-------
                    var finalUsdtBalance = await _quoteAssetBalanceTcs.Task.WaitAsync(cancellationTokenSource.Token);
                    _quoteAssetBalanceTcs = new TaskCompletionSource<decimal>(); // Re-create for next cycle
                    FileLogger.LogOther($"[Arbitrage] Final USDT balance received: {finalUsdtBalance}");

                    FileLogger.LogOther("[Arbitrage] Cycle complete.");
                    await CleanupAndSignalCompletionAsync(finalUsdtBalance);
=======
                    var usdtProceeds = order.CumulativeQuoteQuantity;
                    _quoteAssetBalanceTcs = new TaskCompletionSource<decimal>(); // Re-create for next cycle
                    FileLogger.LogOther($"[Arbitrage] Sale executed. USDT proceeds: {usdtProceeds}");

                    FileLogger.LogOther("[Arbitrage] Cycle complete.");
                    await CleanupAndSignalCompletionAsync(usdtProceeds);
>>>>>>> REPLACE
```

### Change 5: `Program.cs` - Orchestrator Logic

```diff
<<<<<<< SEARCH
:start_line:38
-------
            var cycleState = new ArbitrageCycleState();

            // LEG 1: Gate.io (BUY limit trailing) -> Bybit (SELL market)
            var arbitrageTrader = new ArbitrageTrader(gateIoExchange, bybitExchange);
            var leg1SellQuantity = await arbitrageTrader.StartAsync(gateIoConfig.Symbol, gateIoConfig.Amount, gateIoConfig.DurationMinutes, cycleState);

            FileLogger.LogOther("\n[X7] --- LEG 1 (X1-X7) cycle finished ---");

            if (leg1SellQuantity > 0)
            {
                FileLogger.LogOther($"[Orchestrator] Leg 1 finished. Starting Leg 2.");
                // LEG 2 (Y1-Y7): Bybit (BUY limit trailing) -> Gate.io (SELL market)
                FileLogger.LogOther("\n[Y1] --- Starting LEG 2 (Y1-Y7) ---");
                var reverseArbitrageTrader = new ReverseArbitrageTrader(bybitExchange, gateIoExchange);
                await reverseArbitrageTrader.StartAsync(bybitConfig.Symbol, bybitConfig.Amount, bybitConfig.DurationMinutes, cycleState);
            }
=======
            var cycleState = new ArbitrageCycleState();

            // Step 0: Get initial H balance from Gate.io
            var baseAsset = gateIoConfig.Symbol.Split('_')[0];
            var initialGateIoBalance = await gateIoExchange.GetBalanceAsync(baseAsset);
            cycleState.InitialGateIoBaseAssetBalance = initialGateIoBalance;
            FileLogger.LogOther($"[Orchestrator] Stored initial Gate.io {baseAsset} balance: {initialGateIoBalance}");

            // LEG 1: Gate.io (BUY limit trailing) -> Bybit (SELL market)
            var arbitrageTrader = new ArbitrageTrader(gateIoExchange, bybitExchange);
            var leg1UsdtResult = await arbitrageTrader.StartAsync(gateIoConfig.Symbol, gateIoConfig.Amount, gateIoConfig.DurationMinutes, cycleState);

            FileLogger.LogOther("\n[X7] --- LEG 1 (X1-X7) cycle finished ---");

            if (leg1UsdtResult > 0)
            {
                FileLogger.LogOther($"[Orchestrator] Leg 1 finished with {leg1UsdtResult} USDT. Starting Leg 2.");
                // LEG 2 (Y1-Y7): Bybit (BUY limit trailing) -> Gate.io (SELL market)
                FileLogger.LogOther("\n[Y1] --- Starting LEG 2 (Y1-Y7) ---");
                var reverseArbitrageTrader = new ReverseArbitrageTrader(bybitExchange, gateIoExchange);
                await reverseArbitrageTrader.StartAsync(bybitConfig.Symbol, leg1UsdtResult, bybitConfig.DurationMinutes, cycleState);
            }
>>>>>>> REPLACE
```

### Change 6: `ReverseArbitrageTrader.cs` - Use Initial Balance for Final Sell

```diff
<<<<<<< SEARCH
:start_line:166
-------
                decimal factor = (decimal)Math.Pow(10, _sellBasePrecision);
                var sellQuantity = Math.Truncate(actualQuantity * factor) / factor;
                FileLogger.LogOther($"[Y5] Immediately selling {sellQuantity} on GateIoExchange (original from Bybit Leg 2: {actualQuantity}).");
=======
                decimal factor = (decimal)Math.Pow(10, _sellBasePrecision);
                // Use the initial balance stored at the very beginning of the cycle
                var sellQuantity = Math.Truncate(_state.InitialGateIoBaseAssetBalance * factor) / factor;
                FileLogger.LogOther($"[Y5] Immediately selling {sellQuantity} on GateIoExchange (original from Gate.io pre-cycle balance: {_state.InitialGateIoBaseAssetBalance}).");
>>>>>>> REPLACE
```

## 3. Rationale

These changes precisely implement the logic from `main_process_flow.md`. By adding `CumulativeQuoteQuantity`, we get the exact proceeds from a sale, making the capital flow between legs accurate. The orchestrator now correctly prepares the initial state and passes the correct data. Finally, `Leg 2` performs the correct rebalancing action.

## 4. Risk Assessment

- **Risk:** Medium. Changes are spread across multiple core files.
- **Mitigation:** The plan is broken down into small, verifiable steps. We will apply and test each change incrementally.

## 5. Testing Plan

1.  Apply changes 1, 2, and 3. Test.
2.  Apply change 4. Test.
3.  Apply change 5. Test.
4.  Apply change 6. Test.
5.  Run the full cycle and verify logs against `main_process_flow.md`.

## 6. Rollback Steps

-   Revert changes in each file in the reverse order of application.