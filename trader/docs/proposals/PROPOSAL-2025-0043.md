# PROPOSAL-2025-0043: Add CumulativeQuoteQuantity to IOrder Interface

## 1. Compact Diagnostic

To accurately track the USDT proceeds from a sale, as required by the target logic in `main_process_flow.md`, we need a standardized way to access the cumulative executed value of an order. The current `IOrder` interface lacks this.

This proposal adds a single property, `CumulativeQuoteQuantity`, to the `IOrder` interface and implements it in the Bybit and Gate.io adapters.

## 2. Proposed Changes

### Change 1: `trader/src/Core/IExchange.cs`

```diff
<<<<<<< SEARCH
:start_line:26
-------
        decimal QuoteQuantity { get; }
        string Status { get; }
=======
        decimal QuoteQuantity { get; }
        decimal CumulativeQuoteQuantity { get; }
        string Status { get; }
>>>>>>> REPLACE
```

### Change 2: `trader/src/Exchanges/Bybit/Adapters.cs`

```diff
<<<<<<< SEARCH
:start_line:19
-------
        public decimal QuoteQuantity => _order.QuoteQuantity;
        public string Status => _order.Status;
=======
        public decimal QuoteQuantity => _order.QuoteQuantity;
        public decimal CumulativeQuoteQuantity => _order.CumulativeExecutedValue;
        public string Status => _order.Status;
>>>>>>> REPLACE
```

### Change 3: `trader/src/Exchanges/GateIo/Adapters.cs`

```diff
<<<<<<< SEARCH
:start_line:21
-------
        public decimal QuoteQuantity => _order.QuoteQuantityFilled;
        public string Status => _order.Event.ToString();
=======
        public decimal QuoteQuantity => _order.QuoteQuantityFilled;
        public decimal CumulativeQuoteQuantity => _order.QuoteQuantityFilled; // Gate.io provides this directly
        public string Status => _order.Event.ToString();
>>>>>>> REPLACE
```

## 3. Rationale

This foundational change allows higher-level components (`ArbitrageTrader`) to access the exact proceeds of a trade in a standardized, exchange-agnostic way. It is the first necessary step to implementing the full target logic.

## 4. Risk Assessment

- **Risk:** Low. This change is additive to an interface and its implementations. It will not break existing logic, as no code currently calls the new property.
- **Mitigation:** The change is small and can be easily verified by a successful compilation.

## 5. Testing Plan

1.  Approve and apply all three diffs.
2.  Запустить сборку проекта.
3.  **Expected Outcome:** The project compiles successfully. No change in runtime behavior is expected, as the new property is not yet used.

## 6. Rollback Steps

-   Revert the changes in all three files.