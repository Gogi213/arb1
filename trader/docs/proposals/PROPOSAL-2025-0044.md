# PROPOSAL-2025-0044: Use CumulativeQuoteQuantity for Leg 1 Result

## 1. Диагностика

В соответствии с анализом логов от `30.10.2025 02:33`, `ArbitrageTrader` (Leg 1) некорректно определяет результат своей работы. Вместо того чтобы передавать точное количество USDT, полученное от продажи на Bybit (значение `cumExecValue`), он ожидает общего обновления баланса кошелька `wallet` и передает всю сумму.

Это приводит к тому, что `ReverseArbitrageTrader` (Leg 2) получает завышенную сумму и предсказуемо терпит неудачу при попытке покупки на Bybit с ошибкой `Insufficient balance`.

Данное поведение нарушает **Шаг 4** документа `flows/main_process_flow.md`.

## 2. Предлагаемое изменение

Это изменение исправляет логику в `ArbitrageTrader`, заставляя его использовать новое свойство `order.CumulativeQuoteQuantity` (введенное в `PROPOSAL-2025-0043`) для получения точной выручки от сделки. Ожидание обновления баланса `USDT` полностью убирается, так как вся необходимая информация уже содержится в сообщении об исполнении ордера.

### `trader/src/Core/ArbitrageTrader.cs`

```diff
<<<<<<< SEARCH
:start_line:213
-------
        private async Task HandleSellOrderUpdate(IOrder order, CancellationTokenSource cancellationTokenSource)
        {
            FileLogger.LogOther($"[Arbitrage] Sell order update: OrderId={order.OrderId}, Status={order.Status}, FinishType={order.FinishType}");
            FileLogger.LogOther($"[Arbitrage] Sell fill server time: {order.UpdatedTime:HH:mm:ss.fff}, Update received: {DateTime.UtcNow:HH:mm:ss.fff}");
            FileLogger.LogOther($"[Latency] WS propagation delay (Bybit fill -> handler): {(DateTime.UtcNow - order.UpdatedTime).TotalMilliseconds:F0}ms");

            if (order.Status == "Filled")
            {
                FileLogger.LogOther($"[Arbitrage] Sell order {order.OrderId} CONFIRMED filled on {_sellExchange.Name}!");
                FileLogger.LogOther($"[Latency] END-TO-END (Gate fill -> Bybit fill) SERVER TIME: {(order.UpdatedTime - _buyOrderFilledServerTime).TotalMilliseconds}ms");
                FileLogger.LogOther($"[Latency] END-TO-END (Gate handler -> Bybit confirmation) LOCAL TIME: {(DateTime.UtcNow - _buyOrderFilledLocalTime).TotalMilliseconds}ms");

                // Now wait for the USDT balance update
                FileLogger.LogOther($"[Arbitrage] Waiting for final balance update for asset '{_quoteAsset}'...");
                var finalUsdtBalance = await _quoteAssetBalanceTcs.Task.WaitAsync(cancellationTokenSource.Token);
                FileLogger.LogOther($"[Arbitrage] Final USDT balance received: {finalUsdtBalance}");

                await CleanupAndSignalCompletionAsync(finalUsdtBalance);
            }
        }
=======
        private async Task HandleSellOrderUpdate(IOrder order, CancellationTokenSource cancellationTokenSource)
        {
            FileLogger.LogOther($"[Arbitrage] Sell order update: OrderId={order.OrderId}, Status={order.Status}, FinishType={order.FinishType}");
            FileLogger.LogOther($"[Arbitrage] Sell fill server time: {order.UpdatedTime:HH:mm:ss.fff}, Update received: {DateTime.UtcNow:HH:mm:ss.fff}");
            FileLogger.LogOther($"[Latency] WS propagation delay (Bybit fill -> handler): {(DateTime.UtcNow - order.UpdatedTime).TotalMilliseconds:F0}ms");

            if (order.Status == "Filled")
            {
                FileLogger.LogOther($"[Arbitrage] Sell order {order.OrderId} CONFIRMED filled on {_sellExchange.Name}!");
                FileLogger.LogOther($"[Latency] END-TO-END (Gate fill -> Bybit fill) SERVER TIME: {(order.UpdatedTime - _buyOrderFilledServerTime).TotalMilliseconds}ms");
                FileLogger.LogOther($"[Latency] END-TO-END (Gate handler -> Bybit confirmation) LOCAL TIME: {(DateTime.UtcNow - _buyOrderFilledLocalTime).TotalMilliseconds}ms");

                var usdtProceeds = order.CumulativeQuoteQuantity;
                FileLogger.LogOther($"[Arbitrage] Sale executed. USDT proceeds from order.CumulativeQuoteQuantity: {usdtProceeds}");

                await CleanupAndSignalCompletionAsync(usdtProceeds);
            }
        }
>>>>>>> REPLACE
```

## 3. Обоснование

Изменение напрямую реализует **Шаг 4** из `main_process_flow.md`. Оно устраняет зависимость от ненадежного и медленного обновления общего баланса, используя вместо этого точные данные из самого ордера. Это должно решить проблему `Insufficient balance` в Leg 2 и сделать поток данных корректным и более быстрым.

## 4. Оценка рисков

-   **Риск:** Низкий. Изменение изолировано в `ArbitrageTrader` и затрагивает только способ определения конечной суммы. Логика покупки и продажи остается неизменной.
-   **Смягчение:** Код будет проверен на компиляцию. В случае непредвиденного поведения откат тривиален.

## 5. План тестирования

1.  Утвердить и применить изменение.
2.  Запустить сборку проекта.
3.  Запустить приложение.
4.  **Ожидаемый результат:**
    *   Leg 1 в логах `other.txt` должен показать строку `Sale executed. USDT proceeds from order.CumulativeQuoteQuantity: <сумма>`.
    *   Leg 2 должен стартовать с этой же суммой.
    *   Ошибки `Insufficient balance` в `websocket.txt` и `other.txt` должны исчезнуть. Leg 2 должен успешно выставить ордер на покупку.

## 6. План отката

-   Восстановить предыдущую версию файла `trader/src/Core/ArbitrageTrader.cs`.