# PROPOSAL-2025-0054: Исправление передачи объема для продажи в Leg 2

## Диагностика

При выполнении `Leg 2` арбитражного цикла, попытка продать актив `H` на бирже Gate.io завершается ошибкой `Your order size ... is too small`.
Анализ кода и логов показал, что в качестве количества для продажи (`quantity`) используется некорректное значение.
Текущая реализация в `ReverseArbitrageTrader.cs` использует свойство `_state.GateIoLeg1BuyQuantity`. Это свойство, в свою очередь, заполняется в `ArbitrageTrader.cs` на основе общего баланса после покупки, а не на основе фактически исполненного объема ордера. Это делает логику хрупкой и приводит к передаче неверного значения, если, например, событие обновления баланса не приходит вовремя.

Задача — обеспечить, чтобы в `Leg 2` на Gate.io продавался **ровно тот объем, который был куплен** на Gate.io в `Leg 1`, как и было указано в постановке задачи.

## Предлагаемое изменение

### 1. Добавить новое свойство в `ArbitrageCycleState`

Нужно добавить специальное поле для хранения фактически исполненного объема покупки в `Leg 1`.

**Файл:** `trader/src/Core/ArbitrageCycleState.cs`
```diff
--- a/trader/src/Core/ArbitrageCycleState.cs
+++ b/trader/src/Core/ArbitrageCycleState.cs
@@ -3,6 +3,7 @@
 {
     public class ArbitrageCycleState
     {
+        public decimal Leg1GateBuyFilledQuantity { get; set; }
         public decimal GateIoLeg1BuyQuantity { get; set; }
 
         /// <summary>
```

### 2. Сохранять исполненный объем в `ArbitrageTrader`

Изменим `ArbitrageTrader`, чтобы он сохранял точный исполненный объем из события `OnOrderFilled` в новое свойство состояния. Это надежнее, чем ждать обновления баланса.

**Файл:** `trader/src/Core/ArbitrageTrader.cs`
```diff
--- a/trader/src/Core/ArbitrageTrader.cs
+++ b/trader/src/Core/ArbitrageTrader.cs
@@ -102,6 +102,9 @@
 
                 FileLogger.LogOther($"[Arbitrage] Buy order {filledOrder.OrderId} filled on {_buyExchange.GetType().Name}!");
                 FileLogger.LogOther($"[Arbitrage] Buy fill server time: {buyFillServerTimeStr}, Handler entered: {t0:HH:mm:ss.fff}");
+                _state.Leg1GateBuyFilledQuantity = filledOrder.QuantityFilled;
+                FileLogger.LogOther($"[Arbitrage] Storing Leg 1 filled quantity in state: {filledOrder.QuantityFilled}");
                 
                 // --- NEW LOGIC: Wait for the actual balance update ---
 
```

### 3. Использовать сохраненный объем в `ReverseArbitrageTrader`

Изменим `ReverseArbitrageTrader`, чтобы он использовал новое, точное значение из состояния для ордера на продажу в `Leg 2`.

**Файл:** `trader/src/Exchanges/Bybit/ReverseArbitrageTrader.cs`
```diff
--- a/trader/src/Exchanges/Bybit/ReverseArbitrageTrader.cs
+++ b/trader/src/Exchanges/Bybit/ReverseArbitrageTrader.cs
@@ -48,11 +48,11 @@
 
             var sellSymbol = filledOrder.Symbol.Replace("_", "");
 
-             // THIS IS THE BUG! It's using the quantity from the Bybit buy order.
-             // It should use _state.InitialGateIoBaseAssetBalance
-             var sellQuantity = _state.GateIoLeg1BuyQuantity;
+            // Use the precise filled quantity from the Leg 1 Gate.io buy order
+            var sellQuantity = _state.Leg1GateBuyFilledQuantity;
 LAG_BREAK
-             FileLogger.LogOther($"[Reverse] Quantity to sell on Gate.io: {sellQuantity} (from State.GateIoLeg1BuyQuantity)");
+             FileLogger.LogOther($"[Reverse] Quantity to sell on Gate.io: {sellQuantity} (from State.Leg1GateBuyFilledQuantity)");
 
             var sellOrderId = await _sellExchange.PlaceOrderAsync(
                 sellSymbol,
```

## Обоснование

1.  **Надежность:** Изменение устраняет зависимость от хрупкого механизма отслеживания баланса через WebSocket (который, судя по логам, может не работать стабильно) и вместо этого использует прямое, гарантированное значение из события исполнения ордера.
2.  **Корректность:** Логика приводится в точное соответствие с требованием "продать столько же, сколько купили", что обеспечивает корректное замыкание арбитражного цикла.
3.  **Прозрачность:** Дополнительное логирование делает поток данных между этапами цикла более очевидным.

## Оценка рисков

-   **Низкий:** Изменения хирургические и затрагивают только передачу одного значения (`quantity`). Остальная логика, включая исполнение ордеров на Bybit и трейлинг на Gate.io, не изменяется.

## План тестирования

1.  Запустить приложение после применения изменений.
2.  Проверить логи, чтобы убедиться, что:
    -   В `other.txt` появилось сообщение `[Arbitrage] Storing Leg 1 filled quantity in state: ...` с корректным объемом.
    -   В `other.txt` появилось сообщение `[Reverse] Quantity to sell on Gate.io: ... (from State.Leg1GateBuyFilledQuantity)` с тем же объемом.
    -   В `websocket.txt` отсутствует ошибка `Your order size ... is too small` от Gate.io.
    -   Ордер на продажу на Gate.io в `Leg 2` успешно исполняется.

## План отката

1.  Отменить все три изменения в файлах `ArbitrageCycleState.cs`, `ArbitrageTrader.cs` и `ReverseArbitrageTrader.cs` с помощью `git restore <file>`.
2.  Пересобрать проект.