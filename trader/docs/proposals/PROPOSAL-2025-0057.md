# PROPOSAL-2025-0057: Внедрение версионированного контракта данных для WebSocket

## Диагностика

Проект `trader` падает с ошибкой десериализации, когда проект `collections` начинает транслировать по WebSocket сообщения разных типов (`SpreadData`, `TradeData`). Это происходит потому, что `trader` ожидает единый формат сообщений. Создание общей библиотеки с моделями данных приведет к нежелательной жесткой зависимости между проектами.

## Предлагаемое изменение: JSON-контракт с полем "Тип"

Чтобы обеспечить независимое развитие проектов, предлагается ввести "мягкий" контракт данных. Каждое WebSocket-сообщение от `collections` должно быть JSON-объектом, содержащим поле `MessageType`, которое однозначно идентифицирует тип данных в сообщении.

### 1. Изменения в проекте `collections`

При сериализации любого объекта (`SpreadData`, `TradeData`) перед отправкой по WebSocket, необходимо оборачивать его в общую структуру с указанием типа.

**Пример JSON-сообщения для спреда:**
```json
{
  "MessageType": "Spread",
  "Payload": {
    "Exchange": "GateIo",
    "Symbol": "H_USDT",
    "BestBid": 0.278,
    "BestAsk": 0.279,
    "Timestamp": "2025-10-31T10:00:00Z"
  }
}
```

**Пример JSON-сообщения для сделки:**
```json
{
  "MessageType": "Trade",
  "Payload": {
    "Exchange": "Bybit",
    "Symbol": "H_USDT",
    "Price": 0.2785,
    "Quantity": 100,
    "Side": "Buy",
    "Timestamp": "2025-10-31T10:00:01Z"
  }
}
```

### 2. Изменения в проекте `trader`

`SpreadListener` должен быть модифицирован для работы с этим контрактом.

**Логика в `SpreadListener.ReceiveLoop`:**
1.  Получить сырое JSON-сообщение.
2.  Десериализовать его в `JsonNode` (или аналогичный динамический объект).
3.  Прочитать значение поля `MessageType`.
4.  **Если `MessageType == "Spread"`:**
    -   Извлечь вложенный объект `Payload`.
    -   Десериализовать `Payload` в локальный класс `SpreadData`.
    -   Передать на дальнейшую обработку.
5.  **Если `MessageType` другой (например, "Trade") или отсутствует:**
    -   Проигнорировать сообщение и залогировать, что получен неизвестный тип.

## Обоснование

-   **Отсутствие жестких зависимостей:** Проекты не ссылаются друг на друга. `trader` зависит только от *структуры* JSON, а не от конкретной сборки `collections`.
-   **Расширяемость:** `collections` может добавлять новые типы сообщений (`OrderBookSnapshot`, `FundingRate` и т.д.), не ломая при этом `trader`. `trader` просто будет их игнорировать, пока для них не будет добавлена логика обработки.
-   **Надежность:** `trader` становится устойчивым к изменениям в `collections`, что критически важно для двух независимых сервисов.

## Оценка рисков

-   **Низкий:** Риск заключается в возможной опечатке в строковом значении `MessageType`. Это можно минимизировать, используя константы внутри каждого проекта. Преимущества гибкости и отсутствия зависимостей значительно перевешивают этот риск.