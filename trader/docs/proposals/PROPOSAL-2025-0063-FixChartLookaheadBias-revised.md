# PROPOSAL-2025-0063 (Revised): Устранение ошибки "заглядывания в будущее" и повышение надежности в `charts`

**Дата:** 2025-11-04
**Статус:** Пересмотрено

## 1. Компактная диагностика

Первоначальное предложение (PROPOSAL-2025-0063) было справедливо отклонено из-за недостаточной оценки рисков. Замена `strategy="nearest"` на `strategy="backward"` без дополнительной обработки могла привести к ошибкам при вычислении спреда, если `join_asof` не находил совпадающих данных и создавал `null` значения.

Данное пересмотренное предложение решает обе проблемы:
1.  Устраняет ошибку "заглядывания в будущее" (look-ahead bias).
2.  Добавляет надежную обработку `null` значений, чтобы предотвратить падение сервера.

## 2. Предлагаемое изменение

Внести изменения в файл `charts/server.py`, которые не только исправляют стратегию объединения, но и добавляют явную фильтрацию невалидных данных *после* вычисления спреда.

**Файл:** `charts/server.py`

```diff
--- a/charts/server.py
+++ b/charts/server.py
@@ -70,9 +70,8 @@
     df_b = df_b.with_columns(clean_price_polars(pl.col("BestBid")).alias("bid_b")).sort("timestamp")
 
     # Polars asof_join is extremely fast
-    merged_df = df_a.join_asof(df_b, on="timestamp", strategy="nearest")
-    merged_df = merged_df.drop_nulls()
-
+    # Используем 'backward' для предотвращения "заглядывания в будущее".
+    merged_df = df_a.join_asof(df_b, on="timestamp", strategy="backward")
     if merged_df.height == 0:
         return None
 
@@ -80,6 +79,9 @@
     result_df = merged_df.with_columns(
         (((pl.col('bid_a') / pl.col('bid_b')) - 1) * 100).alias('spread')
     )
+
+    # Фильтруем строки, где спред не мог быть вычислен (из-за отсутствия данных от df_b)
+    result_df = result_df.filter(pl.col('spread').is_not_null())
     
     # Convert to epoch seconds for uPlot
     timestamps = (result_df.get_column("timestamp").dt.epoch(time_unit="ms") / 1000).to_list()

```

## 3. Обоснование

Этот подход является более надежным по двум причинам:
1.  **`strategy="backward"`** исправляет исходную логическую ошибку, как и ранее.
2.  Удаление `merged_df.drop_nulls()` и добавление `result_df.filter(pl.col('spread').is_not_null())` обеспечивает отказоустойчивость. `join_asof` с `backward` стратегией создаст `null` в колонке `bid_b` для тех временных меток `df_a`, для которых нет предшествующих данных в `df_b`. Попытка вычислить спред с `null` также даст `null`. Финальная фильтрация безопасно удаляет только те строки, где вычисление спреда было невозможно, не затрагивая валидные данные и не приводя к падению.

## 4. Оценка рисков

Риск значительно снижен по сравнению с предыдущим предложением. Этот подход является идиоматичным для библиотеки Polars и явно обрабатывает потенциальные ошибки. Код становится более предсказуемым и устойчивым к рассинхронизации потоков данных.

## 5. План тестирования

План остается прежним, но с дополнительным акцентом на проверку стабильности:
1.  Применить предлагаемое изменение к файлу `charts/server.py`.
2.  Перезапустить сервер `uvicorn`.
3.  Обновить страницу `charts/index.html` в браузере.
4.  Убедиться, что аномальные спреды исчезли.
5.  Убедиться, что сервер продолжает работать стабильно, даже если потоки данных не идеально синхронизированы (например, при временном отсутствии данных с одной из бирж).

## 6. План отката

В случае непредвиденных проблем, откатить все изменения в файле `charts/server.py` к его первоначальному состоянию.